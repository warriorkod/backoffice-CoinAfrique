(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('ng2-pica')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs', 'ng2-pica'], factory) :
	(factory((global['ng2-img-max'] = global['ng2-img-max'] || {}),global.ng.core,global.Rx,global.ng2Pica));
}(this, (function (exports,_angular_core,rxjs,ng2Pica) { 'use strict';

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*
The MIT License (MIT)

Copyright (c) 2015 Allan Bishop and contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var Fraction = /** @class */ (function (_super) {
    __extends(Fraction, _super);
    function Fraction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Fraction;
}(Number));
// Console debug wrapper that makes code looks a little bit cleaner
var Debug = /** @class */ (function () {
    function Debug() {
    }
    Debug.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (Exif.debug) {
            console.log(args);
        }
    };
    return Debug;
}());
var Exif = /** @class */ (function () {
    function Exif() {
    }
    Exif.addEvent = function (element, event, handler) {
        if (element.addEventListener) {
            element.addEventListener(event, handler, false);
        }
        else {
            // Hello, IE!
            if (element.attachEvent) {
                element.attachEvent('on' + event, handler);
            }
        }
    };
    Exif.imageHasData = function (img) {
        return !!(img.exifdata);
    };
    Exif.base64ToArrayBuffer = function (base64) {
        base64 = base64.replace(/^data:([^;]+);base64,/gmi, '');
        var binary = atob(base64);
        var len = binary.length;
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        for (var i = 0; i < len; i++) {
            view[i] = binary.charCodeAt(i);
        }
        return buffer;
    };
    Exif.objectURLToBlob = function (url, callback) {
        var http = new XMLHttpRequest();
        http.open('GET', url, true);
        http.responseType = 'blob';
        http.onload = function () {
            if (http.status === 200 || http.status === 0) {
                callback(http.response);
            }
        };
        http.send();
    };
    Exif.getImageData = function (img, callback) {
        function handleBinaryFile(binFile) {
            var data = Exif.findEXIFinJPEG(binFile);
            var iptcdata = Exif.findIPTCinJPEG(binFile);
            img.exifdata = data || {};
            img.iptcdata = iptcdata || {};
            if (callback) {
                callback.call(img);
            }
        }
        if ('src' in img && img.src) {
            if (/^data:/i.test(img.src)) {
                var arrayBuffer = Exif.base64ToArrayBuffer(img.src);
                handleBinaryFile(arrayBuffer);
            }
            else {
                if (/^blob:/i.test(img.src)) {
                    var fileReader_1 = new FileReader();
                    fileReader_1.onload = function (e) {
                        handleBinaryFile(e.target.result);
                    };
                    Exif.objectURLToBlob(img.src, function (blob) {
                        fileReader_1.readAsArrayBuffer(blob);
                    });
                }
                else {
                    var http_1 = new XMLHttpRequest();
                    http_1.onload = function () {
                        if (http_1.status === 200 || http_1.status === 0) {
                            handleBinaryFile(http_1.response);
                        }
                        else {
                            throw 'Could not load image';
                        }
                    };
                    http_1.open('GET', img.src, true);
                    http_1.responseType = 'arraybuffer';
                    http_1.send(null);
                }
            }
        }
        else {
            if (FileReader && (img instanceof Blob || img instanceof File)) {
                var fileReader = new FileReader();
                fileReader.onload = function (e) {
                    Debug.log('Got file of length ' + e.target.result.byteLength);
                    handleBinaryFile(e.target.result);
                };
                fileReader.readAsArrayBuffer(img);
            }
        }
    };
    Exif.findEXIFinJPEG = function (file) {
        var dataView = new DataView(file);
        Debug.log('Got file of length ' + file.byteLength);
        if ((dataView.getUint8(0) !== 0xFF) || (dataView.getUint8(1) !== 0xD8)) {
            Debug.log('Not a valid JPEG');
            return false; // not a valid jpeg
        }
        var offset = 2;
        var length = file.byteLength;
        var marker;
        while (offset < length) {
            if (dataView.getUint8(offset) !== 0xFF) {
                Debug.log('Not a valid marker at offset ' + offset + ', found: ' + dataView.getUint8(offset));
                return false; // not a valid marker, something is wrong
            }
            marker = dataView.getUint8(offset + 1);
            Debug.log(marker);
            // we could implement handling for other markers here,
            // but we're only looking for 0xFFE1 for EXIF data
            if (marker === 225) {
                Debug.log('Found 0xFFE1 marker');
                return Exif.readEXIFData(dataView, offset + 4); // , dataView.getUint16(offset + 2) - 2);
                // offset += 2 + file.getShortAt(offset+2, true);
            }
            else {
                offset += 2 + dataView.getUint16(offset + 2);
            }
        }
    };
    Exif.findIPTCinJPEG = function (file) {
        var dataView = new DataView(file);
        Debug.log('Got file of length ' + file.byteLength);
        if ((dataView.getUint8(0) !== 0xFF) || (dataView.getUint8(1) !== 0xD8)) {
            Debug.log('Not a valid JPEG');
            return false; // not a valid jpeg
        }
        var offset = 2;
        var length = file.byteLength;
        var isFieldSegmentStart = function (_dataView, _offset) {
            return (_dataView.getUint8(_offset) === 0x38 && _dataView.getUint8(_offset + 1) === 0x42 && _dataView.getUint8(_offset + 2) === 0x49 && _dataView.getUint8(_offset + 3) === 0x4D && _dataView.getUint8(_offset + 4) === 0x04 && _dataView.getUint8(_offset + 5) === 0x04);
        };
        while (offset < length) {
            if (isFieldSegmentStart(dataView, offset)) {
                // Get the length of the name header (which is padded to an even number of bytes)
                var nameHeaderLength = dataView.getUint8(offset + 7);
                if (nameHeaderLength % 2 !== 0) {
                    nameHeaderLength += 1;
                }
                // Check for pre photoshop 6 format
                if (nameHeaderLength === 0) {
                    // Always 4
                    nameHeaderLength = 4;
                }
                var startOffset = offset + 8 + nameHeaderLength;
                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);
                return Exif.readIPTCData(file, startOffset, sectionLength);
            }
            // Not the marker, continue searching
            offset++;
        }
    };
    Exif.readIPTCData = function (file, startOffset, sectionLength) {
        var dataView = new DataView(file);
        var data = {};
        var fieldValue, fieldName, dataSize, segmentType, segmentSize;
        var segmentStartPos = startOffset;
        while (segmentStartPos < startOffset + sectionLength) {
            if (dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos + 1) === 0x02) {
                segmentType = dataView.getUint8(segmentStartPos + 2);
                if (segmentType in Exif.IptcFieldMap) {
                    dataSize = dataView.getInt16(segmentStartPos + 3);
                    segmentSize = dataSize + 5;
                    fieldName = Exif.IptcFieldMap[segmentType];
                    fieldValue = Exif.getStringFromDB(dataView, segmentStartPos + 5, dataSize);
                    // Check if we already stored a value with this name
                    if (data.hasOwnProperty(fieldName)) {
                        // Value already stored with this name, create multivalue field
                        if (data[fieldName] instanceof Array) {
                            data[fieldName].push(fieldValue);
                        }
                        else {
                            data[fieldName] = [data[fieldName], fieldValue];
                        }
                    }
                    else {
                        data[fieldName] = fieldValue;
                    }
                }
            }
            segmentStartPos++;
        }
        return data;
    };
    Exif.readTags = function (file, tiffStart, dirStart, strings, bigEnd) {
        var entries = file.getUint16(dirStart, !bigEnd);
        var tags = {};
        var entryOffset;
        var tag;
        for (var i = 0; i < entries; i++) {
            entryOffset = dirStart + i * 12 + 2;
            tag = strings[file.getUint16(entryOffset, !bigEnd)];
            if (!tag) {
                Debug.log('Unknown tag: ' + file.getUint16(entryOffset, !bigEnd));
            }
            tags[tag] = Exif.readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
        }
        return tags;
    };
    Exif.readTagValue = function (file, entryOffset, tiffStart, dirStart, bigEnd) {
        var type = file.getUint16(entryOffset + 2, !bigEnd);
        var numValues = file.getUint32(entryOffset + 4, !bigEnd);
        var valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart;
        var offset;
        var vals, val, n;
        var numerator;
        var denominator;
        switch (type) {
            case 1: // byte, 8-bit unsigned int
            case 7:// undefined, 8-bit byte, value depending on field
                if (numValues === 1) {
                    return file.getUint8(entryOffset + 8, !bigEnd);
                }
                else {
                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getUint8(offset + n);
                    }
                    return vals;
                }
            case 2:// ascii, 8-bit byte
                offset = numValues > 4 ? valueOffset : (entryOffset + 8);
                return Exif.getStringFromDB(file, offset, numValues - 1);
            case 3:// short, 16 bit int
                if (numValues === 1) {
                    return file.getUint16(entryOffset + 8, !bigEnd);
                }
                else {
                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getUint16(offset + 2 * n, !bigEnd);
                    }
                    return vals;
                }
            case 4:// long, 32 bit int
                if (numValues === 1) {
                    return file.getUint32(entryOffset + 8, !bigEnd);
                }
                else {
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);
                    }
                    return vals;
                }
            case 5:// rational = two long values, first is numerator, second is denominator
                if (numValues === 1) {
                    numerator = file.getUint32(valueOffset, !bigEnd);
                    denominator = file.getUint32(valueOffset + 4, !bigEnd);
                    val = new Fraction(numerator / denominator);
                    val.numerator = numerator;
                    val.denominator = denominator;
                    return val;
                }
                else {
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);
                        denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);
                        vals[n] = new Fraction(numerator / denominator);
                        vals[n].numerator = numerator;
                        vals[n].denominator = denominator;
                    }
                    return vals;
                }
            case 9:// slong, 32 bit signed int
                if (numValues === 1) {
                    return file.getInt32(entryOffset + 8, !bigEnd);
                }
                else {
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);
                    }
                    return vals;
                }
            case 10:// signed rational, two slongs, first is numerator, second is denominator
                if (numValues === 1) {
                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset + 4, !bigEnd);
                }
                else {
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getInt32(valueOffset + 8 * n, !bigEnd) / file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);
                    }
                    return vals;
                }
            default:
                break;
        }
    };
    Exif.getStringFromDB = function (buffer, start, length) {
        var outstr = '';
        for (var n = start; n < start + length; n++) {
            outstr += String.fromCharCode(buffer.getUint8(n));
        }
        return outstr;
    };
    Exif.readEXIFData = function (file, start) {
        if (Exif.getStringFromDB(file, start, 4) !== 'Exif') {
            Debug.log('Not valid EXIF data! ' + Exif.getStringFromDB(file, start, 4));
            return false;
        }
        var bigEnd, tags, tag, exifData, gpsData, tiffOffset = start + 6;
        // test for TIFF validity and endianness
        if (file.getUint16(tiffOffset) === 0x4949) {
            bigEnd = false;
        }
        else {
            if (file.getUint16(tiffOffset) === 0x4D4D) {
                bigEnd = true;
            }
            else {
                Debug.log('Not valid TIFF data! (no 0x4949 or 0x4D4D)');
                return false;
            }
        }
        if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
            Debug.log('Not valid TIFF data! (no 0x002A)');
            return false;
        }
        var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);
        if (firstIFDOffset < 0x00000008) {
            Debug.log('Not valid TIFF data! (First offset less than 8)', file.getUint32(tiffOffset + 4, !bigEnd));
            return false;
        }
        tags = Exif.readTags(file, tiffOffset, tiffOffset + firstIFDOffset, Exif.TiffTags, bigEnd);
        if (tags.ExifIFDPointer) {
            exifData = Exif.readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, Exif.Tags, bigEnd);
            for (tag in exifData) {
                if ({}.hasOwnProperty.call(exifData, tag)) {
                    switch (tag) {
                        case 'LightSource':
                        case 'Flash':
                        case 'MeteringMode':
                        case 'ExposureProgram':
                        case 'SensingMethod':
                        case 'SceneCaptureType':
                        case 'SceneType':
                        case 'CustomRendered':
                        case 'WhiteBalance':
                        case 'GainControl':
                        case 'Contrast':
                        case 'Saturation':
                        case 'Sharpness':
                        case 'SubjectDistanceRange':
                        case 'FileSource':
                            exifData[tag] = Exif.StringValues[tag][exifData[tag]];
                            break;
                        case 'ExifVersion':
                        case 'FlashpixVersion':
                            exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);
                            break;
                        case 'ComponentsConfiguration':
                            var compopents = 'Components';
                            exifData[tag] = Exif.StringValues[compopents][exifData[tag][0]] + Exif.StringValues[compopents][exifData[tag][1]] + Exif.StringValues[compopents][exifData[tag][2]] + Exif.StringValues[compopents][exifData[tag][3]];
                            break;
                        default:
                            break;
                    }
                    tags[tag] = exifData[tag];
                }
            }
        }
        if (tags.GPSInfoIFDPointer) {
            gpsData = Exif.readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, Exif.GPSTags, bigEnd);
            for (tag in gpsData) {
                if ({}.hasOwnProperty.call(gpsData, tag)) {
                    switch (tag) {
                        case 'GPSVersionID':
                            gpsData[tag] = gpsData[tag][0] + '.' + gpsData[tag][1] + '.' + gpsData[tag][2] + '.' + gpsData[tag][3];
                            break;
                        default:
                            break;
                    }
                    tags[tag] = gpsData[tag];
                }
            }
        }
        return tags;
    };
    Exif.getData = function (img, callback) {
        if ((img instanceof Image || img instanceof HTMLImageElement) && !img.complete) {
            return false;
        }
        if (!Exif.imageHasData(img)) {
            Exif.getImageData(img, callback);
        }
        else {
            if (callback) {
                callback.call(img);
            }
        }
        return true;
    };
    Exif.getTag = function (img, tag) {
        if (!Exif.imageHasData(img)) {
            return;
        }
        return img.exifdata[tag];
    };
    
    Exif.getAllTags = function (img) {
        if (!Exif.imageHasData(img)) {
            return {};
        }
        var a, data = img.exifdata, tags = {};
        for (a in data) {
            if (data.hasOwnProperty(a)) {
                tags[a] = data[a];
            }
        }
        return tags;
    };
    
    Exif.pretty = function (img) {
        if (!Exif.imageHasData(img)) {
            return '';
        }
        var a, data = img.exifdata, strPretty = '';
        for (a in data) {
            if (data.hasOwnProperty(a)) {
                if (typeof data[a] === 'object') {
                    if (data[a] instanceof Number) {
                        strPretty += a + " : " + data[a] + " [" + data[a].numerator + "/" + data[a].denominator + "]\r\n";
                    }
                    else {
                        strPretty += a + " : [" + data[a].length + " values]\r\n";
                    }
                }
                else {
                    strPretty += a + " : " + data[a] + "\r\n";
                }
            }
        }
        return strPretty;
    };
    Exif.readFromBinaryFile = function (file) {
        return Exif.findEXIFinJPEG(file);
    };
    Exif.debug = false;
    Exif.IptcFieldMap = {
        '0x78': 'caption',
        '0x6E': 'credit',
        '0x19': 'keywords',
        '0x37': 'dateCreated',
        '0x50': 'byline',
        '0x55': 'bylineTitle',
        '0x7A': 'captionWriter',
        '0x69': 'headline',
        '0x74': 'copyright',
        '0x0F': 'category'
    };
    Exif.Tags = {
        // version tags
        '0x9000': 'ExifVersion',
        '0xA000': 'FlashpixVersion',
        // colorspace tags
        '0xA001': 'ColorSpace',
        // image configuration
        '0xA002': 'PixelXDimension',
        '0xA003': 'PixelYDimension',
        '0x9101': 'ComponentsConfiguration',
        '0x9102': 'CompressedBitsPerPixel',
        // user information
        '0x927C': 'MakerNote',
        '0x9286': 'UserComment',
        // related file
        '0xA004': 'RelatedSoundFile',
        // date and time
        '0x9003': 'DateTimeOriginal',
        '0x9004': 'DateTimeDigitized',
        '0x9290': 'SubsecTime',
        '0x9291': 'SubsecTimeOriginal',
        '0x9292': 'SubsecTimeDigitized',
        // picture-taking conditions
        '0x829A': 'ExposureTime',
        '0x829D': 'FNumber',
        '0x8822': 'ExposureProgram',
        '0x8824': 'SpectralSensitivity',
        '0x8827': 'ISOSpeedRatings',
        '0x8828': 'OECF',
        '0x9201': 'ShutterSpeedValue',
        '0x9202': 'ApertureValue',
        '0x9203': 'BrightnessValue',
        '0x9204': 'ExposureBias',
        '0x9205': 'MaxApertureValue',
        '0x9206': 'SubjectDistance',
        '0x9207': 'MeteringMode',
        '0x9208': 'LightSource',
        '0x9209': 'Flash',
        '0x9214': 'SubjectArea',
        '0x920A': 'FocalLength',
        '0xA20B': 'FlashEnergy',
        '0xA20C': 'SpatialFrequencyResponse',
        '0xA20E': 'FocalPlaneXResolution',
        '0xA20F': 'FocalPlaneYResolution',
        '0xA210': 'FocalPlaneResolutionUnit',
        '0xA214': 'SubjectLocation',
        '0xA215': 'ExposureIndex',
        '0xA217': 'SensingMethod',
        '0xA300': 'FileSource',
        '0xA301': 'SceneType',
        '0xA302': 'CFAPattern',
        '0xA401': 'CustomRendered',
        '0xA402': 'ExposureMode',
        '0xA403': 'WhiteBalance',
        '0xA404': 'DigitalZoomRation',
        '0xA405': 'FocalLengthIn35mmFilm',
        '0xA406': 'SceneCaptureType',
        '0xA407': 'GainControl',
        '0xA408': 'Contrast',
        '0xA409': 'Saturation',
        '0xA40A': 'Sharpness',
        '0xA40B': 'DeviceSettingDescription',
        '0xA40C': 'SubjectDistanceRange',
        // other tags
        '0xA005': 'InteroperabilityIFDPointer',
        '0xA420': 'ImageUniqueID' // Identifier assigned uniquely to each image
    };
    Exif.TiffTags = {
        '0x0100': 'ImageWidth',
        '0x0101': 'ImageHeight',
        '0x8769': 'ExifIFDPointer',
        '0x8825': 'GPSInfoIFDPointer',
        '0xA005': 'InteroperabilityIFDPointer',
        '0x0102': 'BitsPerSample',
        '0x0103': 'Compression',
        '0x0106': 'PhotometricInterpretation',
        '0x0112': 'Orientation',
        '0x0115': 'SamplesPerPixel',
        '0x011C': 'PlanarConfiguration',
        '0x0212': 'YCbCrSubSampling',
        '0x0213': 'YCbCrPositioning',
        '0x011A': 'XResolution',
        '0x011B': 'YResolution',
        '0x0128': 'ResolutionUnit',
        '0x0111': 'StripOffsets',
        '0x0116': 'RowsPerStrip',
        '0x0117': 'StripByteCounts',
        '0x0201': 'JPEGInterchangeFormat',
        '0x0202': 'JPEGInterchangeFormatLength',
        '0x012D': 'TransferFunction',
        '0x013E': 'WhitePoint',
        '0x013F': 'PrimaryChromaticities',
        '0x0211': 'YCbCrCoefficients',
        '0x0214': 'ReferenceBlackWhite',
        '0x0132': 'DateTime',
        '0x010E': 'ImageDescription',
        '0x010F': 'Make',
        '0x0110': 'Model',
        '0x0131': 'Software',
        '0x013B': 'Artist',
        '0x8298': 'Copyright'
    };
    Exif.GPSTags = {
        '0x0000': 'GPSVersionID',
        '0x0001': 'GPSLatitudeRef',
        '0x0002': 'GPSLatitude',
        '0x0003': 'GPSLongitudeRef',
        '0x0004': 'GPSLongitude',
        '0x0005': 'GPSAltitudeRef',
        '0x0006': 'GPSAltitude',
        '0x0007': 'GPSTimeStamp',
        '0x0008': 'GPSSatellites',
        '0x0009': 'GPSStatus',
        '0x000A': 'GPSMeasureMode',
        '0x000B': 'GPSDOP',
        '0x000C': 'GPSSpeedRef',
        '0x000D': 'GPSSpeed',
        '0x000E': 'GPSTrackRef',
        '0x000F': 'GPSTrack',
        '0x0010': 'GPSImgDirectionRef',
        '0x0011': 'GPSImgDirection',
        '0x0012': 'GPSMapDatum',
        '0x0013': 'GPSDestLatitudeRef',
        '0x0014': 'GPSDestLatitude',
        '0x0015': 'GPSDestLongitudeRef',
        '0x0016': 'GPSDestLongitude',
        '0x0017': 'GPSDestBearingRef',
        '0x0018': 'GPSDestBearing',
        '0x0019': 'GPSDestDistanceRef',
        '0x001A': 'GPSDestDistance',
        '0x001B': 'GPSProcessingMethod',
        '0x001C': 'GPSAreaInformation',
        '0x001D': 'GPSDateStamp',
        '0x001E': 'GPSDifferential'
    };
    Exif.StringValues = {
        ExposureProgram: {
            '0': 'Not defined',
            '1': 'Manual',
            '2': 'Normal program',
            '3': 'Aperture priority',
            '4': 'Shutter priority',
            '5': 'Creative program',
            '6': 'Action program',
            '7': 'Portrait mode',
            '8': 'Landscape mode'
        }, MeteringMode: {
            '0': 'Unknown',
            '1': 'Average',
            '2': 'CenterWeightedAverage',
            '3': 'Spot',
            '4': 'MultiSpot',
            '5': 'Pattern',
            '6': 'Partial',
            '255': 'Other'
        }, LightSource: {
            '0': 'Unknown',
            '1': 'Daylight',
            '2': 'Fluorescent',
            '3': 'Tungsten (incandescent light)',
            '4': 'Flash',
            '9': 'Fine weather',
            '10': 'Cloudy weather',
            '11': 'Shade',
            '12': 'Daylight fluorescent (D 5700 - 7100K)',
            '13': 'Day white fluorescent (N 4600 - 5400K)',
            '14': 'Cool white fluorescent (W 3900 - 4500K)',
            '15': 'White fluorescent (WW 3200 - 3700K)',
            '17': 'Standard light A',
            '18': 'Standard light B',
            '19': 'Standard light C',
            '20': 'D55',
            '21': 'D65',
            '22': 'D75',
            '23': 'D50',
            '24': 'ISO studio tungsten',
            '255': 'Other'
        }, Flash: {
            '0x0000': 'Flash did not fire',
            '0x0001': 'Flash fired',
            '0x0005': 'Strobe return light not detected',
            '0x0007': 'Strobe return light detected',
            '0x0009': 'Flash fired, compulsory flash mode',
            '0x000D': 'Flash fired, compulsory flash mode, return light not detected',
            '0x000F': 'Flash fired, compulsory flash mode, return light detected',
            '0x0010': 'Flash did not fire, compulsory flash mode',
            '0x0018': 'Flash did not fire, auto mode',
            '0x0019': 'Flash fired, auto mode',
            '0x001D': 'Flash fired, auto mode, return light not detected',
            '0x001F': 'Flash fired, auto mode, return light detected',
            '0x0020': 'No flash function',
            '0x0041': 'Flash fired, red-eye reduction mode',
            '0x0045': 'Flash fired, red-eye reduction mode, return light not detected',
            '0x0047': 'Flash fired, red-eye reduction mode, return light detected',
            '0x0049': 'Flash fired, compulsory flash mode, red-eye reduction mode',
            '0x004D': 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
            '0x004F': 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
            '0x0059': 'Flash fired, auto mode, red-eye reduction mode',
            '0x005D': 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
            '0x005F': 'Flash fired, auto mode, return light detected, red-eye reduction mode'
        }, SensingMethod: {
            '1': 'Not defined',
            '2': 'One-chip color area sensor',
            '3': 'Two-chip color area sensor',
            '4': 'Three-chip color area sensor',
            '5': 'Color sequential area sensor',
            '7': 'Trilinear sensor',
            '8': 'Color sequential linear sensor'
        }, SceneCaptureType: {
            '0': 'Standard', '1': 'Landscape', '2': 'Portrait', '3': 'Night scene'
        }, SceneType: {
            '1': 'Directly photographed'
        }, CustomRendered: {
            '0': 'Normal process', '1': 'Custom process'
        }, WhiteBalance: {
            '0': 'Auto white balance', '1': 'Manual white balance'
        }, GainControl: {
            '0': 'None', '1': 'Low gain up', '2': 'High gain up', '3': 'Low gain down', '4': 'High gain down'
        }, Contrast: {
            '0': 'Normal', '1': 'Soft', '2': 'Hard'
        }, Saturation: {
            '0': 'Normal', '1': 'Low saturation', '2': 'High saturation'
        }, Sharpness: {
            '0': 'Normal', '1': 'Soft', '2': 'Hard'
        }, SubjectDistanceRange: {
            '0': 'Unknown', '1': 'Macro', '2': 'Close view', '3': 'Distant view'
        }, FileSource: {
            '3': 'DSC'
        },
        Components: {
            '0': '', '1': 'Y', '2': 'Cb', '3': 'Cr', '4': 'R', '5': 'G', '6': 'B'
        }
    };
    return Exif;
}());

var ImgExifService = /** @class */ (function () {
    function ImgExifService() {
    }
    ImgExifService.prototype.getOrientedImage = function (image) {
        var result = new Promise(function (resolve, reject) {
            var img;
            Exif.getData(image, function () {
                var orientation = Exif.getTag(image, "Orientation");
                if (orientation != 1) {
                    var canvas = document.createElement("canvas"), ctx = canvas.getContext("2d"), cw = image.width, ch = image.height, cx = 0, cy = 0, deg = 0;
                    switch (orientation) {
                        case 3:
                        case 4:
                            cx = -image.width;
                            cy = -image.height;
                            deg = 180;
                            break;
                        case 5:
                        case 6:
                            cw = image.height;
                            ch = image.width;
                            cy = -image.height;
                            deg = 90;
                            break;
                        case 7:
                        case 8:
                            cw = image.height;
                            ch = image.width;
                            cx = -image.width;
                            deg = 270;
                            break;
                        default:
                            break;
                    }
                    canvas.width = cw;
                    canvas.height = ch;
                    if ([2, 4, 5, 7].indexOf(orientation) > -1) {
                        //flip image
                        ctx.translate(cw, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.rotate(deg * Math.PI / 180);
                    ctx.drawImage(image, cx, cy);
                    img = document.createElement("img");
                    img.width = cw;
                    img.height = ch;
                    img.addEventListener('load', function () {
                        resolve(img);
                    });
                    img.src = canvas.toDataURL("image/png");
                }
                else {
                    resolve(image);
                }
            });
        });
        return result;
    };
    ImgExifService.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ImgExifService.ctorParameters = function () { return []; };
    return ImgExifService;
}());

var MAX_STEPS = 15;
var ImgMaxSizeService = /** @class */ (function () {
    function ImgMaxSizeService(imageExifService) {
        this.imageExifService = imageExifService;
    }
    ImgMaxSizeService.prototype.compressImage = function (file, maxSizeInMB, ignoreAlpha, logExecutionTime) {
        var _this = this;
        if (ignoreAlpha === void 0) { ignoreAlpha = false; }
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        var compressedFileSubject = new rxjs.Subject();
        this.timeAtStart = new Date().getTime();
        this.initialFile = file;
        if (file.type !== "image/jpeg" && file.type !== "image/png") {
            //END OF COMPRESSION
            setTimeout(function () {
                compressedFileSubject.error({ compressedFile: file, reason: "File provided is neither of type jpg nor of type png.", error: "INVALID_EXTENSION" });
            }, 0);
            return compressedFileSubject.asObservable();
        }
        var oldFileSize = file.size / 1024 / 1024;
        if (oldFileSize < maxSizeInMB) {
            // END OF COMPRESSION
            // FILE SIZE ALREADY BELOW MAX_SIZE -> no compression needed
            setTimeout(function () { compressedFileSubject.next(file); }, 0);
            return compressedFileSubject.asObservable();
        }
        var cvs = document.createElement('canvas');
        var ctx = cvs.getContext('2d');
        var img = new Image();
        var self = this;
        img.onload = function () {
            _this.imageExifService.getOrientedImage(img).then(function (orientedImg) {
                window.URL.revokeObjectURL(img.src);
                cvs.width = orientedImg.width;
                cvs.height = orientedImg.height;
                ctx.drawImage(orientedImg, 0, 0);
                var imageData = ctx.getImageData(0, 0, orientedImg.width, orientedImg.height);
                if (file.type === "image/png" && _this.isImgUsingAlpha(imageData) && !ignoreAlpha) {
                    //png image with alpha
                    compressedFileSubject.error({ compressedFile: file, reason: "File provided is a png image which uses the alpha channel. No compression possible.", error: "PNG_WITH_ALPHA" });
                }
                ctx = cvs.getContext('2d', { 'alpha': false });
                ctx.drawImage(orientedImg, 0, 0);
                self.getCompressedFile(cvs, 50, maxSizeInMB, 1).then(function (compressedFile) {
                    compressedFileSubject.next(compressedFile);
                    self.logExecutionTime(logExecutionTime);
                }).catch(function (error) {
                    compressedFileSubject.error(error);
                    self.logExecutionTime(logExecutionTime);
                });
            });
        };
        img.src = window.URL.createObjectURL(file);
        return compressedFileSubject.asObservable();
    };
    
    ImgMaxSizeService.prototype.getCompressedFile = function (cvs, quality, maxSizeInMB, currentStep) {
        var _this = this;
        var result = new Promise(function (resolve, reject) {
            cvs.toBlob(function (blob) {
                if (currentStep + 1 > MAX_STEPS) {
                    //COMPRESSION END
                    //maximal steps reached
                    reject({ compressedFile: _this.getResultFile(blob), reason: "Could not find the correct compression quality in " + MAX_STEPS + " steps.", error: "MAX_STEPS_EXCEEDED" });
                }
                else {
                    var newQuality = _this.getCalculatedQuality(blob, quality, maxSizeInMB, currentStep);
                    _this.checkCompressionStatus(cvs, blob, quality, maxSizeInMB, currentStep, newQuality)
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (result) {
                        reject(result);
                    });
                }
            }, "image/jpeg", quality / 100);
        });
        return result;
    };
    ImgMaxSizeService.prototype.getResultFile = function (blob) {
        return this.generateResultFile(blob, this.initialFile.name, this.initialFile.type, new Date().getTime());
    };
    ImgMaxSizeService.prototype.generateResultFile = function (blob, name, type, lastModified) {
        var resultFile = new Blob([blob], { type: type });
        return this.blobToFile(resultFile, name, lastModified);
    };
    ImgMaxSizeService.prototype.blobToFile = function (blob, name, lastModified) {
        var file = blob;
        file.name = name;
        file.lastModified = lastModified;
        //Cast to a File() type
        return file;
    };
    ImgMaxSizeService.prototype.getCalculatedQuality = function (blob, quality, maxSizeInMB, currentStep) {
        //CALCULATE NEW QUALITY
        var currentSize = blob.size / 1024 / 1024;
        var ratioMaxSizeToCurrentSize = maxSizeInMB / currentSize;
        if (ratioMaxSizeToCurrentSize > 5) {
            //max ratio to avoid extreme quality values
            ratioMaxSizeToCurrentSize = 5;
        }
        var ratioMaxSizeToInitialSize = currentSize / (this.initialFile.size / 1024 / 1024);
        if (ratioMaxSizeToInitialSize < 0.05) {
            //min ratio to avoid extreme quality values
            ratioMaxSizeToInitialSize = 0.05;
        }
        var newQuality = 0;
        var multiplicator = Math.abs(ratioMaxSizeToInitialSize - 1) * 10 / (currentStep * 1.7) / ratioMaxSizeToCurrentSize;
        if (multiplicator < 1) {
            multiplicator = 1;
        }
        if (ratioMaxSizeToCurrentSize >= 1) {
            newQuality = quality + (ratioMaxSizeToCurrentSize - 1) * 10 * multiplicator;
        }
        else {
            newQuality = quality - (1 - ratioMaxSizeToCurrentSize) * 10 * multiplicator;
        }
        if (newQuality > 100) {
            //max quality = 100, so let's set the new quality to the value in between the old quality and 100 in case of > 100
            newQuality = quality + (100 - quality) / 2;
        }
        if (newQuality < 0) {
            //min quality = 0, so let's set the new quality to the value in between the old quality and 0 in case of < 0
            newQuality = quality - quality / 2;
        }
        return newQuality;
    };
    ImgMaxSizeService.prototype.checkCompressionStatus = function (cvs, blob, quality, maxSizeInMB, currentStep, newQuality) {
        var _this = this;
        var result = new Promise(function (resolve, reject) {
            if (quality === 100 && newQuality >= 100) {
                //COMPRESSION END
                //Seems like quality 100 is max but file still too small, case that shouldn't exist as the compression shouldn't even have started in the first place
                reject({ compressedFile: _this.initialFile, reason: "Unfortunately there was an error while compressing the file.", error: "FILE_BIGGER_THAN_INITIAL_FILE" });
            }
            else if ((quality < 1) && (newQuality < quality)) {
                //COMPRESSION END
                //File size still too big but can't compress further than quality=0
                reject({ compressedFile: _this.getResultFile(blob), reason: "Could not compress image enough to fit the maximal file size limit.", error: "UNABLE_TO_COMPRESS_ENOUGH" });
            }
            else if ((newQuality > quality) && (Math.round(quality) == Math.round(newQuality))) {
                //COMPRESSION END
                //next steps quality would be the same quality but newQuality is slightly bigger than old one, means we most likely found the nearest quality to compress to maximal size
                resolve(_this.getResultFile(blob));
            }
            else if (currentStep > 5 && (newQuality > quality) && (newQuality < quality + 2)) {
                //COMPRESSION END
                //for some rare occasions the algorithm might be stuck around e.g. 98.5 and 97.4 because of the maxQuality of 100, the current quality is the nearest possible quality in that case
                resolve(_this.getResultFile(blob));
            }
            else if ((newQuality > quality) && Number.isInteger(quality) && (Math.floor(newQuality) == quality)) {
                //COMPRESSION END
                /*
                    in the previous step if ((quality > newQuality) && (Math.round(quality) == Math.round(newQuality))) applied, so
                    newQuality = Math.round(newQuality) - 1; this was done to reduce the quality at least a full integer down to not waste a step
                    with the same compression rate quality as before. Now, the newQuality is still only in between the old quality (e.g. 93)
                    and the newQuality (e.g. 94) which most likely means that the value for the newQuality (the bigger one) would make the filesize
                    too big so we should just stick with the current, lower quality and return that file.
                */
                resolve(_this.getResultFile(blob));
            }
            else {
                //CONTINUE COMPRESSION
                if ((quality > newQuality) && (Math.round(quality) == Math.round(newQuality))) {
                    //quality can only be an integer -> make sure difference between old quality and new one is at least a whole integer number
                    // - it would be nonsense to compress again with the same quality
                    newQuality = Math.round(newQuality) - 1;
                }
                //recursively call function again
                resolve(_this.getCompressedFile(cvs, newQuality, maxSizeInMB, currentStep + 1));
            }
        });
        return result;
    };
    ImgMaxSizeService.prototype.isImgUsingAlpha = function (imageData) {
        for (var i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 255) {
                return true;
            }
        }
        return false;
    };
    ImgMaxSizeService.prototype.logExecutionTime = function (logExecutionTime) {
        if (logExecutionTime) {
            console.info("Execution time: ", new Date().getTime() - this.timeAtStart + "ms");
        }
    };
    ImgMaxSizeService.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ImgMaxSizeService.ctorParameters = function () { return [
        { type: ImgExifService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgExifService; }),] },] },
    ]; };
    return ImgMaxSizeService;
}());

var ImgMaxPXSizeService = /** @class */ (function () {
    function ImgMaxPXSizeService(ng2PicaService, imageExifService) {
        this.ng2PicaService = ng2PicaService;
        this.imageExifService = imageExifService;
    }
    ImgMaxPXSizeService.prototype.resizeImage = function (file, maxWidth, maxHeight, logExecutionTime) {
        var _this = this;
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        var resizedFileSubject = new rxjs.Subject();
        this.timeAtStart = new Date().getTime();
        if (file.type !== "image/jpeg" && file.type !== "image/png") {
            //END OF RESIZE
            setTimeout(function () {
                resizedFileSubject.error({ resizedFile: file, reason: "The provided File is neither of type jpg nor of type png.", error: "INVALID_EXTENSION" });
            }, 0);
            return resizedFileSubject.asObservable();
        }
        var img = new Image();
        var self = this;
        img.onload = function () {
            _this.imageExifService.getOrientedImage(img).then(function (orientedImg) {
                window.URL.revokeObjectURL(img.src);
                var currentWidth = orientedImg.width;
                var currentHeight = orientedImg.height;
                var newWidth = currentWidth;
                var newHeight = currentHeight;
                if (newWidth > maxWidth) {
                    newWidth = maxWidth;
                    //resize height proportionally
                    var ratio = maxWidth / currentWidth; //is gonna be <1
                    newHeight = newHeight * ratio;
                }
                currentHeight = newHeight;
                if (newHeight > maxHeight) {
                    newHeight = maxHeight;
                    //resize width proportionally
                    var ratio = maxHeight / currentHeight; //is gonna be <1
                    newWidth = newWidth * ratio;
                }
                if (newHeight === orientedImg.height && newWidth === orientedImg.width) {
                    //no resizing necessary
                    resizedFileSubject.next(file);
                    self.logExecutionTime(logExecutionTime);
                }
                else {
                    self.ng2PicaService.resize([file], newWidth, newHeight).subscribe(function (result) {
                        //all good, result is a file
                        resizedFileSubject.next(result);
                        self.logExecutionTime(logExecutionTime);
                    }, function (error) {
                        //something went wrong 
                        resizedFileSubject.error({ resizedFile: file, reason: error, error: "PICA_ERROR" });
                        self.logExecutionTime(logExecutionTime);
                    });
                }
            });
        };
        img.src = window.URL.createObjectURL(file);
        return resizedFileSubject.asObservable();
    };
    
    ImgMaxPXSizeService.prototype.logExecutionTime = function (logExecutionTime) {
        if (logExecutionTime) {
            console.info("Execution time: ", new Date().getTime() - this.timeAtStart + "ms");
        }
    };
    ImgMaxPXSizeService.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ImgMaxPXSizeService.ctorParameters = function () { return [
        { type: ng2Pica.Ng2PicaService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ng2Pica.Ng2PicaService; }),] },] },
        { type: ImgExifService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgExifService; }),] },] },
    ]; };
    return ImgMaxPXSizeService;
}());

var Ng2ImgMaxService = /** @class */ (function () {
    function Ng2ImgMaxService(imgMaxSizeService, imgMaxPXSizeService, imageExifService) {
        this.imgMaxSizeService = imgMaxSizeService;
        this.imgMaxPXSizeService = imgMaxPXSizeService;
        this.imageExifService = imageExifService;
    }
    Ng2ImgMaxService.prototype.compress = function (files, maxSizeInMB, ignoreAlpha, logExecutionTime) {
        var _this = this;
        if (ignoreAlpha === void 0) { ignoreAlpha = false; }
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        var compressedFileSubject = new rxjs.Subject();
        files.forEach(function (file) {
            _this.compressImage(file, maxSizeInMB, ignoreAlpha, logExecutionTime).subscribe(function (value) {
                compressedFileSubject.next(value);
            }, function (error) {
                compressedFileSubject.error(error);
            });
        });
        return compressedFileSubject.asObservable();
    };
    Ng2ImgMaxService.prototype.resize = function (files, maxWidth, maxHeight, logExecutionTime) {
        var _this = this;
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        var resizedFileSubject = new rxjs.Subject();
        files.forEach(function (file) {
            _this.resizeImage(file, maxWidth, maxHeight, logExecutionTime).subscribe(function (value) {
                resizedFileSubject.next(value);
            }, function (error) {
                resizedFileSubject.error(error);
            });
        });
        return resizedFileSubject.asObservable();
    };
    Ng2ImgMaxService.prototype.compressImage = function (file, maxSizeInMB, ignoreAlpha, logExecutionTime) {
        if (ignoreAlpha === void 0) { ignoreAlpha = false; }
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        return this.imgMaxSizeService.compressImage(file, maxSizeInMB, ignoreAlpha, logExecutionTime);
    };
    Ng2ImgMaxService.prototype.resizeImage = function (file, maxWidth, maxHeight, logExecutionTime) {
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        return this.imgMaxPXSizeService.resizeImage(file, maxWidth, maxHeight, logExecutionTime);
    };
    Ng2ImgMaxService.prototype.getEXIFOrientedImage = function (image) {
        return this.imageExifService.getOrientedImage(image);
    };
    Ng2ImgMaxService.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    Ng2ImgMaxService.ctorParameters = function () { return [
        { type: ImgMaxSizeService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgMaxSizeService; }),] },] },
        { type: ImgMaxPXSizeService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgMaxPXSizeService; }),] },] },
        { type: ImgExifService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgExifService; }),] },] },
    ]; };
    return Ng2ImgMaxService;
}());

var Ng2ImgMaxModule = /** @class */ (function () {
    function Ng2ImgMaxModule() {
    }
    Ng2ImgMaxModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    imports: [
                        ng2Pica.Ng2PicaModule
                    ],
                    providers: [
                        { provide: ImgMaxPXSizeService, useClass: ImgMaxPXSizeService },
                        { provide: ImgMaxSizeService, useClass: ImgMaxSizeService },
                        { provide: ImgExifService, useClass: ImgExifService },
                        { provide: Ng2ImgMaxService, useClass: Ng2ImgMaxService }
                    ]
                },] },
    ];
    /** @nocollapse */
    Ng2ImgMaxModule.ctorParameters = function () { return []; };
    return Ng2ImgMaxModule;
}());

exports.Ng2ImgMaxService = Ng2ImgMaxService;
exports.Ng2ImgMaxModule = Ng2ImgMaxModule;
exports.ImgMaxSizeService = ImgMaxSizeService;
exports.ImgMaxPXSizeService = ImgMaxPXSizeService;
exports.ImgExifService = ImgExifService;

Object.defineProperty(exports, '__esModule', { value: true });

})));
