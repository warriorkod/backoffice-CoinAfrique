(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('moment')) :
    typeof define === 'function' && define.amd ? define('ngx-moment', ['exports', '@angular/core', 'moment'], factory) :
    (factory((global['ngx-moment'] = {}),global.ng.core,global.moment));
}(this, (function (exports,core,moment) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor = moment;
    var AddPipe = /** @class */ (function () {
        function AddPipe() {
        }
        /**
         * @param {?} value
         * @param {?} amount
         * @param {?=} unit
         * @return {?}
         */
        AddPipe.prototype.transform = /**
         * @param {?} value
         * @param {?} amount
         * @param {?=} unit
         * @return {?}
         */
            function (value, amount, unit) {
                if (typeof amount === 'undefined' || (typeof amount === 'number' && typeof unit === 'undefined')) {
                    throw new Error('AddPipe: missing required arguments');
                }
                return momentConstructor(value).add(amount, unit);
            };
        AddPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amAdd' },] }
        ];
        return AddPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$1 = moment;
    var CalendarPipe = /** @class */ (function () {
        function CalendarPipe(cdRef, ngZone) {
            var _this = this;
            this.cdRef = cdRef;
            this.ngZone = ngZone;
            // using a single static timer for all instances of this pipe for performance reasons
            CalendarPipe.initTimer(ngZone);
            CalendarPipe.refs++;
            // values such as Today will need to be replaced with Yesterday after midnight,
            // so make sure we subscribe to an EventEmitter that we set up to emit at midnight
            this.midnightSub = CalendarPipe.midnight.subscribe(function () {
                _this.ngZone.run(function () { return _this.cdRef.markForCheck(); });
            });
        }
        /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
        CalendarPipe.prototype.transform = /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
            function (value) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                /** @type {?} */
                var formats = null;
                /** @type {?} */
                var referenceTime = null;
                for (var i = 0, len = args.length; i < len; i++) {
                    if (args[i] !== null) {
                        if (typeof args[i] === 'object' && !moment.isMoment(args[i])) {
                            formats = args[i];
                        }
                        else {
                            referenceTime = momentConstructor$1(args[i]);
                        }
                    }
                }
                return momentConstructor$1(value).calendar(referenceTime, formats);
            };
        /**
         * @return {?}
         */
        CalendarPipe.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (CalendarPipe.refs > 0) {
                    CalendarPipe.refs--;
                }
                if (CalendarPipe.refs === 0) {
                    CalendarPipe.removeTimer();
                }
                this.midnightSub.unsubscribe();
            };
        /**
         * @param {?} ngZone
         * @return {?}
         */
        CalendarPipe.initTimer = /**
         * @param {?} ngZone
         * @return {?}
         */
            function (ngZone) {
                // initialize the timer
                if (!CalendarPipe.midnight) {
                    CalendarPipe.midnight = new core.EventEmitter();
                    if (typeof window !== 'undefined') {
                        /** @type {?} */
                        var timeToUpdate_1 = CalendarPipe._getMillisecondsUntilUpdate();
                        CalendarPipe.timer = ngZone.runOutsideAngular(function () {
                            return window.setTimeout(function () {
                                // emit the current date
                                CalendarPipe.midnight.emit(new Date());
                                // refresh the timer
                                CalendarPipe.removeTimer();
                                CalendarPipe.initTimer(ngZone);
                            }, timeToUpdate_1);
                        });
                    }
                }
            };
        /**
         * @return {?}
         */
        CalendarPipe.removeTimer = /**
         * @return {?}
         */
            function () {
                if (CalendarPipe.timer) {
                    window.clearTimeout(CalendarPipe.timer);
                    CalendarPipe.timer = null;
                    CalendarPipe.midnight = null;
                }
            };
        /**
         * @return {?}
         */
        CalendarPipe._getMillisecondsUntilUpdate = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var now = momentConstructor$1();
                /** @type {?} */
                var tomorrow = momentConstructor$1().startOf('day').add(1, 'days');
                /** @type {?} */
                var timeToMidnight = tomorrow.valueOf() - now.valueOf();
                return timeToMidnight + 1000; // 1 second after midnight
            };
        /**
         * Internal reference counter, so we can clean up when no instances are in use
         */
        CalendarPipe.refs = 0;
        CalendarPipe.timer = null;
        CalendarPipe.midnight = null;
        CalendarPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amCalendar', pure: false },] }
        ];
        /** @nocollapse */
        CalendarPipe.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef },
                { type: core.NgZone }
            ];
        };
        return CalendarPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$2 = moment;
    var DateFormatPipe = /** @class */ (function () {
        function DateFormatPipe() {
        }
        /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
        DateFormatPipe.prototype.transform = /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
            function (value) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (!value) {
                    return '';
                }
                return momentConstructor$2(value).format(args[0]);
            };
        DateFormatPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amDateFormat' },] }
        ];
        return DateFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$3 = moment;
    var DifferencePipe = /** @class */ (function () {
        function DifferencePipe() {
        }
        /**
         * @param {?} value
         * @param {?} otherValue
         * @param {?=} unit
         * @param {?=} precision
         * @return {?}
         */
        DifferencePipe.prototype.transform = /**
         * @param {?} value
         * @param {?} otherValue
         * @param {?=} unit
         * @param {?=} precision
         * @return {?}
         */
            function (value, otherValue, unit, precision) {
                /** @type {?} */
                var date = momentConstructor$3(value);
                /** @type {?} */
                var date2 = (otherValue !== null) ? momentConstructor$3(otherValue) : momentConstructor$3();
                return date.diff(date2, unit, precision);
            };
        DifferencePipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amDifference' },] }
        ];
        return DifferencePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NGX_MOMENT_OPTIONS = new core.InjectionToken('NGX_MOMENT_OPTIONS');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DurationPipe = /** @class */ (function () {
        function DurationPipe(momentOptions) {
            this.allowedUnits = ['ss', 's', 'm', 'h', 'd', 'M'];
            this._applyOptions(momentOptions);
        }
        /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
        DurationPipe.prototype.transform = /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
            function (value) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (typeof args === 'undefined' || args.length !== 1) {
                    throw new Error('DurationPipe: missing required time unit argument');
                }
                return moment.duration(value, ( /** @type {?} */(args[0]))).humanize();
            };
        /**
         * @param {?} momentOptions
         * @return {?}
         */
        DurationPipe.prototype._applyOptions = /**
         * @param {?} momentOptions
         * @return {?}
         */
            function (momentOptions) {
                var _this = this;
                if (!momentOptions) {
                    return;
                }
                if (!!momentOptions.relativeTimeThresholdOptions) {
                    /** @type {?} */
                    var units = Object.keys(momentOptions.relativeTimeThresholdOptions);
                    /** @type {?} */
                    var filteredUnits = units.filter(function (unit) { return _this.allowedUnits.indexOf(unit) !== -1; });
                    filteredUnits.forEach(function (unit) {
                        moment.relativeTimeThreshold(unit, momentOptions.relativeTimeThresholdOptions[unit]);
                    });
                }
            };
        DurationPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amDuration' },] }
        ];
        /** @nocollapse */
        DurationPipe.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NGX_MOMENT_OPTIONS,] }] }
            ];
        };
        return DurationPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FromUnixPipe = /** @class */ (function () {
        function FromUnixPipe() {
        }
        /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
        FromUnixPipe.prototype.transform = /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
            function (value) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (typeof value === 'string') {
                    value = +value;
                }
                return moment.unix(value);
            };
        FromUnixPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amFromUnix' },] }
        ];
        return FromUnixPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$4 = moment;
    var ParsePipe = /** @class */ (function () {
        function ParsePipe() {
        }
        /**
         * @param {?} value
         * @param {?} format
         * @return {?}
         */
        ParsePipe.prototype.transform = /**
         * @param {?} value
         * @param {?} format
         * @return {?}
         */
            function (value, format) {
                return momentConstructor$4(value, format);
            };
        ParsePipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amParse' },] }
        ];
        return ParsePipe;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var FromUtcPipe = /** @class */ (function () {
        function FromUtcPipe() {
        }
        /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
        FromUtcPipe.prototype.transform = /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
            function (value) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return moment.utc(value);
            };
        FromUtcPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amFromUtc' },] }
        ];
        return FromUtcPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$5 = moment;
    var IsAfterPipe = /** @class */ (function () {
        function IsAfterPipe() {
        }
        /**
         * @param {?} value
         * @param {?} otherValue
         * @param {?=} unit
         * @return {?}
         */
        IsAfterPipe.prototype.transform = /**
         * @param {?} value
         * @param {?} otherValue
         * @param {?=} unit
         * @return {?}
         */
            function (value, otherValue, unit) {
                return momentConstructor$5(value).isAfter(momentConstructor$5(otherValue), unit);
            };
        IsAfterPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'amIsAfter'
                    },] }
        ];
        return IsAfterPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$6 = moment;
    var IsBeforePipe = /** @class */ (function () {
        function IsBeforePipe() {
        }
        /**
         * @param {?} value
         * @param {?} otherValue
         * @param {?=} unit
         * @return {?}
         */
        IsBeforePipe.prototype.transform = /**
         * @param {?} value
         * @param {?} otherValue
         * @param {?=} unit
         * @return {?}
         */
            function (value, otherValue, unit) {
                return momentConstructor$6(value).isBefore(momentConstructor$6(otherValue), unit);
            };
        IsBeforePipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'amIsBefore'
                    },] }
        ];
        return IsBeforePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$7 = moment;
    var LocalTimePipe = /** @class */ (function () {
        function LocalTimePipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        LocalTimePipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return momentConstructor$7(value).local();
            };
        LocalTimePipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amLocal' },] }
        ];
        return LocalTimePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    // under systemjs, moment is actually exported as the default export, so we account for that
    /** @type {?} */
    var momentConstructor$8 = moment;
    var LocalePipe = /** @class */ (function () {
        function LocalePipe() {
        }
        /**
         * @param {?} value
         * @param {?} locale
         * @return {?}
         */
        LocalePipe.prototype.transform = /**
         * @param {?} value
         * @param {?} locale
         * @return {?}
         */
            function (value, locale) {
                return momentConstructor$8(value).locale(locale);
            };
        LocalePipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amLocale' },] }
        ];
        return LocalePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ParseZonePipe = /** @class */ (function () {
        function ParseZonePipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ParseZonePipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return moment.parseZone(value);
            };
        ParseZonePipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amParseZone' },] }
        ];
        return ParseZonePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$9 = moment;
    var SubtractPipe = /** @class */ (function () {
        function SubtractPipe() {
        }
        /**
         * @param {?} value
         * @param {?} amount
         * @param {?=} unit
         * @return {?}
         */
        SubtractPipe.prototype.transform = /**
         * @param {?} value
         * @param {?} amount
         * @param {?=} unit
         * @return {?}
         */
            function (value, amount, unit) {
                if (typeof amount === 'undefined' || (typeof amount === 'number' && typeof unit === 'undefined')) {
                    throw new Error('SubtractPipe: missing required arguments');
                }
                return momentConstructor$9(value).subtract(amount, unit);
            };
        SubtractPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amSubtract' },] }
        ];
        return SubtractPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$a = moment;
    var TimeAgoPipe = /** @class */ (function () {
        function TimeAgoPipe(cdRef, ngZone) {
            this.cdRef = cdRef;
            this.ngZone = ngZone;
        }
        /**
         * @param {?} value
         * @param {?=} omitSuffix
         * @return {?}
         */
        TimeAgoPipe.prototype.transform = /**
         * @param {?} value
         * @param {?=} omitSuffix
         * @return {?}
         */
            function (value, omitSuffix) {
                if (this.hasChanged(value, omitSuffix)) {
                    this.lastTime = this.getTime(value);
                    this.lastValue = value;
                    this.lastOmitSuffix = omitSuffix;
                    this.lastLocale = this.getLocale(value);
                    this.removeTimer();
                    this.createTimer();
                    this.lastText = momentConstructor$a(value).from(momentConstructor$a(), omitSuffix);
                }
                else {
                    this.createTimer();
                }
                return this.lastText;
            };
        /**
         * @return {?}
         */
        TimeAgoPipe.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.removeTimer();
            };
        /**
         * @return {?}
         */
        TimeAgoPipe.prototype.createTimer = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.currentTimer) {
                    return;
                }
                /** @type {?} */
                var momentInstance = momentConstructor$a(this.lastValue);
                /** @type {?} */
                var timeToUpdate = this.getSecondsUntilUpdate(momentInstance) * 1000;
                this.currentTimer = this.ngZone.runOutsideAngular(function () {
                    if (typeof window !== 'undefined') {
                        return window.setTimeout(function () {
                            _this.lastText = momentConstructor$a(_this.lastValue).from(momentConstructor$a(), _this.lastOmitSuffix);
                            _this.currentTimer = null;
                            _this.ngZone.run(function () { return _this.cdRef.markForCheck(); });
                        }, timeToUpdate);
                    }
                    else {
                        return null;
                    }
                });
            };
        /**
         * @return {?}
         */
        TimeAgoPipe.prototype.removeTimer = /**
         * @return {?}
         */
            function () {
                if (this.currentTimer) {
                    window.clearTimeout(this.currentTimer);
                    this.currentTimer = null;
                }
            };
        /**
         * @param {?} momentInstance
         * @return {?}
         */
        TimeAgoPipe.prototype.getSecondsUntilUpdate = /**
         * @param {?} momentInstance
         * @return {?}
         */
            function (momentInstance) {
                /** @type {?} */
                var howOld = Math.abs(momentConstructor$a().diff(momentInstance, 'minute'));
                if (howOld < 1) {
                    return 1;
                }
                else if (howOld < 60) {
                    return 30;
                }
                else if (howOld < 180) {
                    return 300;
                }
                else {
                    return 3600;
                }
            };
        /**
         * @param {?} value
         * @param {?=} omitSuffix
         * @return {?}
         */
        TimeAgoPipe.prototype.hasChanged = /**
         * @param {?} value
         * @param {?=} omitSuffix
         * @return {?}
         */
            function (value, omitSuffix) {
                return this.getTime(value) !== this.lastTime
                    || this.getLocale(value) !== this.lastLocale
                    || omitSuffix !== this.lastOmitSuffix;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimeAgoPipe.prototype.getTime = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (moment.isDate(value)) {
                    return value.getTime();
                }
                else if (moment.isMoment(value)) {
                    return value.valueOf();
                }
                else {
                    return momentConstructor$a(value).valueOf();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimeAgoPipe.prototype.getLocale = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return moment.isMoment(value) ? value.locale() : moment.locale();
            };
        TimeAgoPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amTimeAgo', pure: false },] }
        ];
        /** @nocollapse */
        TimeAgoPipe.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef },
                { type: core.NgZone }
            ];
        };
        return TimeAgoPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var momentConstructor$b = moment;
    var UtcPipe = /** @class */ (function () {
        function UtcPipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        UtcPipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return momentConstructor$b(value).utc();
            };
        UtcPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'amUtc' },] }
        ];
        return UtcPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ANGULAR_MOMENT_PIPES = [
        AddPipe,
        CalendarPipe,
        DateFormatPipe,
        DifferencePipe,
        DurationPipe,
        FromUnixPipe,
        ParsePipe,
        SubtractPipe,
        TimeAgoPipe,
        UtcPipe,
        FromUtcPipe,
        LocalTimePipe,
        LocalePipe,
        ParseZonePipe,
        IsBeforePipe,
        IsAfterPipe
    ];
    var MomentModule = /** @class */ (function () {
        function MomentModule() {
        }
        /**
         * @param {?=} options
         * @return {?}
         */
        MomentModule.forRoot = /**
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                return {
                    ngModule: MomentModule,
                    providers: [
                        {
                            provide: NGX_MOMENT_OPTIONS, useValue: __assign({}, options)
                        }
                    ]
                };
            };
        MomentModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: ANGULAR_MOMENT_PIPES,
                        exports: ANGULAR_MOMENT_PIPES
                    },] }
        ];
        return MomentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    exports.AddPipe = AddPipe;
    exports.CalendarPipe = CalendarPipe;
    exports.DateFormatPipe = DateFormatPipe;
    exports.DifferencePipe = DifferencePipe;
    exports.DurationPipe = DurationPipe;
    exports.FromUnixPipe = FromUnixPipe;
    exports.ParsePipe = ParsePipe;
    exports.MomentModule = MomentModule;
    exports.SubtractPipe = SubtractPipe;
    exports.TimeAgoPipe = TimeAgoPipe;
    exports.UtcPipe = UtcPipe;
    exports.FromUtcPipe = FromUtcPipe;
    exports.LocalTimePipe = LocalTimePipe;
    exports.LocalePipe = LocalePipe;
    exports.ParseZonePipe = ParseZonePipe;
    exports.IsBeforePipe = IsBeforePipe;
    exports.IsAfterPipe = IsAfterPipe;
    exports.NGX_MOMENT_OPTIONS = NGX_MOMENT_OPTIONS;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LW1vbWVudC51bWQuanMubWFwIiwic291cmNlcyI6WyJuZzovL25neC1tb21lbnQvYWRkLnBpcGUudHMiLCJuZzovL25neC1tb21lbnQvY2FsZW5kYXIucGlwZS50cyIsIm5nOi8vbmd4LW1vbWVudC9kYXRlLWZvcm1hdC5waXBlLnRzIiwibmc6Ly9uZ3gtbW9tZW50L2RpZmZlcmVuY2UucGlwZS50cyIsIm5nOi8vbmd4LW1vbWVudC9tb21lbnQtb3B0aW9ucy50cyIsIm5nOi8vbmd4LW1vbWVudC9kdXJhdGlvbi5waXBlLnRzIiwibmc6Ly9uZ3gtbW9tZW50L2Zyb20tdW5peC5waXBlLnRzIiwibmc6Ly9uZ3gtbW9tZW50L3BhcnNlLnBpcGUudHMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibmc6Ly9uZ3gtbW9tZW50L2Zyb20tdXRjLnBpcGUudHMiLCJuZzovL25neC1tb21lbnQvaXMtYWZ0ZXIucGlwZS50cyIsIm5nOi8vbmd4LW1vbWVudC9pcy1iZWZvcmUucGlwZS50cyIsIm5nOi8vbmd4LW1vbWVudC9sb2NhbC5waXBlLnRzIiwibmc6Ly9uZ3gtbW9tZW50L2xvY2FsZS5waXBlLnRzIiwibmc6Ly9uZ3gtbW9tZW50L3BhcnNlLXpvbmUucGlwZS50cyIsIm5nOi8vbmd4LW1vbWVudC9zdWJ0cmFjdC5waXBlLnRzIiwibmc6Ly9uZ3gtbW9tZW50L3RpbWUtYWdvLnBpcGUudHMiLCJuZzovL25neC1tb21lbnQvdXRjLnBpcGUudHMiLCJuZzovL25neC1tb21lbnQvbW9tZW50Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBuZ3gtbW9tZW50IChjKSAyMDE1LCAyMDE2IFVyaSBTaGFrZWQgLyBNSVQgTGljZW5jZSAqL1xyXG5cclxuaW1wb3J0IHtQaXBlLCBQaXBlVHJhbnNmb3JtfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XHJcblxyXG5jb25zdCBtb21lbnRDb25zdHJ1Y3RvciA9IG1vbWVudDtcclxuXHJcbkBQaXBlKHsgbmFtZTogJ2FtQWRkJyB9KVxyXG5leHBvcnQgY2xhc3MgQWRkUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG4gICAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIGFtb3VudDogbW9tZW50LkR1cmF0aW9uSW5wdXRBcmcxLCB1bml0PzogbW9tZW50LkR1cmF0aW9uSW5wdXRBcmcyKTogYW55IHtcclxuICAgICAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gJ3VuZGVmaW5lZCcgfHwgKHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInICYmIHR5cGVvZiB1bml0ID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRQaXBlOiBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9tZW50Q29uc3RydWN0b3IodmFsdWUpLmFkZChhbW91bnQsIHVuaXQpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qIG5neC1tb21lbnQgKGMpIDIwMTUsIDIwMTYgVXJpIFNoYWtlZCAvIE1JVCBMaWNlbmNlICovXHJcblxyXG5pbXBvcnQgeyBQaXBlLCBDaGFuZ2VEZXRlY3RvclJlZiwgUGlwZVRyYW5zZm9ybSwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50JztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcblxyXG5jb25zdCBtb21lbnRDb25zdHJ1Y3RvciA9IG1vbWVudDtcclxuXHJcbkBQaXBlKHsgbmFtZTogJ2FtQ2FsZW5kYXInLCBwdXJlOiBmYWxzZSB9KVxyXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSwgT25EZXN0cm95IHtcclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJuYWwgcmVmZXJlbmNlIGNvdW50ZXIsIHNvIHdlIGNhbiBjbGVhbiB1cCB3aGVuIG5vIGluc3RhbmNlcyBhcmUgaW4gdXNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgcmVmcyA9IDA7XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIHRpbWVyOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHN0YXRpYyBtaWRuaWdodDogRXZlbnRFbWl0dGVyPERhdGU+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgbWlkbmlnaHRTdWI6IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHtcclxuICAgIC8vIHVzaW5nIGEgc2luZ2xlIHN0YXRpYyB0aW1lciBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGlzIHBpcGUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcclxuICAgIENhbGVuZGFyUGlwZS5pbml0VGltZXIobmdab25lKTtcclxuXHJcbiAgICBDYWxlbmRhclBpcGUucmVmcysrO1xyXG5cclxuICAgIC8vIHZhbHVlcyBzdWNoIGFzIFRvZGF5IHdpbGwgbmVlZCB0byBiZSByZXBsYWNlZCB3aXRoIFllc3RlcmRheSBhZnRlciBtaWRuaWdodCxcclxuICAgIC8vIHNvIG1ha2Ugc3VyZSB3ZSBzdWJzY3JpYmUgdG8gYW4gRXZlbnRFbWl0dGVyIHRoYXQgd2Ugc2V0IHVwIHRvIGVtaXQgYXQgbWlkbmlnaHRcclxuICAgIHRoaXMubWlkbmlnaHRTdWIgPSBDYWxlbmRhclBpcGUubWlkbmlnaHQuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMuY2RSZWYubWFya0ZvckNoZWNrKCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB0cmFuc2Zvcm0odmFsdWU6IERhdGUgfCBtb21lbnQuTW9tZW50LCAuLi5hcmdzOiBhbnlbXSk6IGFueSB7XHJcbiAgICBsZXQgZm9ybWF0czogYW55ID0gbnVsbDtcclxuICAgIGxldCByZWZlcmVuY2VUaW1lOiBhbnkgPSBudWxsO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChhcmdzW2ldICE9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnb2JqZWN0JyAmJiAhbW9tZW50LmlzTW9tZW50KGFyZ3NbaV0pKSB7XHJcbiAgICAgICAgICBmb3JtYXRzID0gYXJnc1tpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVmZXJlbmNlVGltZSA9IG1vbWVudENvbnN0cnVjdG9yKGFyZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtb21lbnRDb25zdHJ1Y3Rvcih2YWx1ZSkuY2FsZW5kYXIocmVmZXJlbmNlVGltZSwgZm9ybWF0cyk7XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgIGlmIChDYWxlbmRhclBpcGUucmVmcyA+IDApIHtcclxuICAgICAgQ2FsZW5kYXJQaXBlLnJlZnMtLTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ2FsZW5kYXJQaXBlLnJlZnMgPT09IDApIHtcclxuICAgICAgQ2FsZW5kYXJQaXBlLnJlbW92ZVRpbWVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5taWRuaWdodFN1Yi51bnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgaW5pdFRpbWVyKG5nWm9uZTogTmdab25lKSB7XHJcbiAgICAvLyBpbml0aWFsaXplIHRoZSB0aW1lclxyXG4gICAgaWYgKCFDYWxlbmRhclBpcGUubWlkbmlnaHQpIHtcclxuICAgICAgQ2FsZW5kYXJQaXBlLm1pZG5pZ2h0ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBjb25zdCB0aW1lVG9VcGRhdGUgPSBDYWxlbmRhclBpcGUuX2dldE1pbGxpc2Vjb25kc1VudGlsVXBkYXRlKCk7XHJcbiAgICAgICAgQ2FsZW5kYXJQaXBlLnRpbWVyID0gbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGN1cnJlbnQgZGF0ZVxyXG4gICAgICAgICAgICBDYWxlbmRhclBpcGUubWlkbmlnaHQuZW1pdChuZXcgRGF0ZSgpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIHRpbWVyXHJcbiAgICAgICAgICAgIENhbGVuZGFyUGlwZS5yZW1vdmVUaW1lcigpO1xyXG4gICAgICAgICAgICBDYWxlbmRhclBpcGUuaW5pdFRpbWVyKG5nWm9uZSk7XHJcbiAgICAgICAgICB9LCB0aW1lVG9VcGRhdGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXRpYyByZW1vdmVUaW1lcigpIHtcclxuICAgIGlmIChDYWxlbmRhclBpcGUudGltZXIpIHtcclxuICAgICAgd2luZG93LmNsZWFyVGltZW91dChDYWxlbmRhclBpcGUudGltZXIpO1xyXG4gICAgICBDYWxlbmRhclBpcGUudGltZXIgPSBudWxsO1xyXG4gICAgICBDYWxlbmRhclBpcGUubWlkbmlnaHQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgX2dldE1pbGxpc2Vjb25kc1VudGlsVXBkYXRlKCkge1xyXG4gICAgY29uc3Qgbm93ID0gbW9tZW50Q29uc3RydWN0b3IoKTtcclxuICAgIGNvbnN0IHRvbW9ycm93ID0gbW9tZW50Q29uc3RydWN0b3IoKS5zdGFydE9mKCdkYXknKS5hZGQoMSwgJ2RheXMnKTtcclxuICAgIGNvbnN0IHRpbWVUb01pZG5pZ2h0ID0gdG9tb3Jyb3cudmFsdWVPZigpIC0gbm93LnZhbHVlT2YoKTtcclxuICAgIHJldHVybiB0aW1lVG9NaWRuaWdodCArIDEwMDA7IC8vIDEgc2Vjb25kIGFmdGVyIG1pZG5pZ2h0XHJcbiAgfVxyXG59XHJcbiIsIi8qIG5neC1tb21lbnQgKGMpIDIwMTUsIDIwMTYgVXJpIFNoYWtlZCAvIE1JVCBMaWNlbmNlICovXHJcblxyXG5pbXBvcnQge1BpcGUsIFBpcGVUcmFuc2Zvcm19IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50JztcclxuXHJcbmNvbnN0IG1vbWVudENvbnN0cnVjdG9yID0gbW9tZW50O1xyXG5cclxuQFBpcGUoeyBuYW1lOiAnYW1EYXRlRm9ybWF0JyB9KVxyXG5leHBvcnQgY2xhc3MgRGF0ZUZvcm1hdFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICB0cmFuc2Zvcm0odmFsdWU6IERhdGUgfCBtb21lbnQuTW9tZW50IHwgc3RyaW5nIHwgbnVtYmVyLCAuLi5hcmdzOiBhbnlbXSk6IHN0cmluZyB7XHJcbiAgICBpZiAoIXZhbHVlKSB7IHJldHVybiAnJzsgfVxyXG4gICAgcmV0dXJuIG1vbWVudENvbnN0cnVjdG9yKHZhbHVlKS5mb3JtYXQoYXJnc1swXSk7XHJcbiAgfVxyXG59XHJcbiIsIi8qIG5neC1tb21lbnQgKGMpIDIwMTUsIDIwMTYgVXJpIFNoYWtlZCAvIE1JVCBMaWNlbmNlICovXHJcblxyXG5pbXBvcnQge1BpcGUsIFBpcGVUcmFuc2Zvcm19IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50JztcclxuXHJcbmNvbnN0IG1vbWVudENvbnN0cnVjdG9yID0gbW9tZW50O1xyXG5cclxuQFBpcGUoeyBuYW1lOiAnYW1EaWZmZXJlbmNlJyB9KVxyXG5leHBvcnQgY2xhc3MgRGlmZmVyZW5jZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICB0cmFuc2Zvcm0odmFsdWU6IERhdGUgfCBtb21lbnQuTW9tZW50LFxyXG4gICAgICAgICAgICBvdGhlclZhbHVlOiBEYXRlIHwgbW9tZW50Lk1vbWVudCxcclxuICAgICAgICAgICAgdW5pdD86IG1vbWVudC51bml0T2ZUaW1lLkRpZmYsXHJcbiAgICAgICAgICAgIHByZWNpc2lvbj86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cclxuICAgIGNvbnN0IGRhdGUgPSBtb21lbnRDb25zdHJ1Y3Rvcih2YWx1ZSk7XHJcbiAgICBjb25zdCBkYXRlMiA9IChvdGhlclZhbHVlICE9PSBudWxsKSA/IG1vbWVudENvbnN0cnVjdG9yKG90aGVyVmFsdWUpIDogbW9tZW50Q29uc3RydWN0b3IoKTtcclxuXHJcbiAgICByZXR1cm4gZGF0ZS5kaWZmKGRhdGUyLCB1bml0LCBwcmVjaXNpb24pO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE5HWF9NT01FTlRfT1BUSU9OUzogSW5qZWN0aW9uVG9rZW48Tmd4TW9tZW50T3B0aW9ucz4gPSBuZXcgSW5qZWN0aW9uVG9rZW48Tmd4TW9tZW50T3B0aW9ucz4oJ05HWF9NT01FTlRfT1BUSU9OUycpO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hNb21lbnRPcHRpb25zIHtcclxuICAvKipcclxuICAgKiByZWxhdGl2ZVRpbWVUaHJlc2hvbGRPcHRpb25zXHJcbiAgICogQGRlc2NyaXB0aW9uIFByb3ZpZGVzIHRoZSBgcmVsYXRpdmVUaW1lVGhyZXNob2xkYCB1bml0cyBhbGxvd2luZyBhIHBpcGUgdG8gc2V0IHRoZSBgbW9tZW50LnJlbGF0aXZlVGltZVRocmVzaG9sZGAgdmFsdWVzLlxyXG4gICAqIFRoZSBga2V5YCBpcyBhIHVuaXQgZGVmaW5lZCBhcyBvbmUgb2YgYHNzYCwgYHNgLCBgbWAsIGBoYCwgYGRgLCBgTWAuXHJcbiAgICogQHNlZSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvY3VzdG9taXphdGlvbi9yZWxhdGl2ZS10aW1lLXRocmVzaG9sZC9cclxuICAgKiBAZXhhbXBsZSBieSBkZWZhdWx0IG1vcmUgdGhhbiA0NSBzZWNvbmRzIGlzIGNvbnNpZGVyZWQgYSBtaW51dGUsIG1vcmUgdGhhbiAyMiBob3VycyBpcyBjb25zaWRlcmVkIGEgZGF5IGFuZCBzbyBvbi5cclxuICAgKiBTbyBzZXR0aW5ncyB0aGUgdW5pdCAnbScgdG8gYDU5YCB3aWxsIGFkanVzdCB0aGUgYHJlbGF0aXZlVGltZVRocmVzaG9sZGAgYW5kIGNvbnNpZGVyIG1vcmUgdGhhbiA1OSBtaW51dGVzXHJcbiAgICogdG8gYmUgYW4gaG91ciAoZGVmYXVsdCBpcyBgNDUgbWludXRlc2ApXHJcbiAgICovXHJcbiAgcmVsYXRpdmVUaW1lVGhyZXNob2xkT3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50JztcclxuXHJcbmltcG9ydCB7IEluamVjdCwgT3B0aW9uYWwsIFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTkdYX01PTUVOVF9PUFRJT05TLCBOZ3hNb21lbnRPcHRpb25zIH0gZnJvbSAnLi9tb21lbnQtb3B0aW9ucyc7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdhbUR1cmF0aW9uJyB9KVxyXG5leHBvcnQgY2xhc3MgRHVyYXRpb25QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcblxyXG4gIGFsbG93ZWRVbml0czogQXJyYXk8c3RyaW5nPiA9IFsnc3MnLCAncycsICdtJywgJ2gnLCAnZCcsICdNJ107XHJcblxyXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoTkdYX01PTUVOVF9PUFRJT05TKSBtb21lbnRPcHRpb25zPzogTmd4TW9tZW50T3B0aW9ucykge1xyXG4gICAgdGhpcy5fYXBwbHlPcHRpb25zKG1vbWVudE9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIC4uLmFyZ3M6IHN0cmluZ1tdKTogc3RyaW5nIHtcclxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJncy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXJhdGlvblBpcGU6IG1pc3NpbmcgcmVxdWlyZWQgdGltZSB1bml0IGFyZ3VtZW50Jyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHZhbHVlLCBhcmdzWzBdIGFzIG1vbWVudC51bml0T2ZUaW1lLkR1cmF0aW9uQ29uc3RydWN0b3IpLmh1bWFuaXplKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9hcHBseU9wdGlvbnMobW9tZW50T3B0aW9uczogTmd4TW9tZW50T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgaWYgKCFtb21lbnRPcHRpb25zKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoISFtb21lbnRPcHRpb25zLnJlbGF0aXZlVGltZVRocmVzaG9sZE9wdGlvbnMpIHtcclxuICAgICAgY29uc3QgdW5pdHM6IEFycmF5PHN0cmluZz4gPSBPYmplY3Qua2V5cyhtb21lbnRPcHRpb25zLnJlbGF0aXZlVGltZVRocmVzaG9sZE9wdGlvbnMpO1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZFVuaXRzOiBBcnJheTxzdHJpbmc+ID0gdW5pdHMuZmlsdGVyKHVuaXQgPT4gdGhpcy5hbGxvd2VkVW5pdHMuaW5kZXhPZih1bml0KSAhPT0gLTEpO1xyXG4gICAgICBmaWx0ZXJlZFVuaXRzLmZvckVhY2godW5pdCA9PiB7XHJcbiAgICAgICAgbW9tZW50LnJlbGF0aXZlVGltZVRocmVzaG9sZCh1bml0LCBtb21lbnRPcHRpb25zLnJlbGF0aXZlVGltZVRocmVzaG9sZE9wdGlvbnNbdW5pdF0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbiIsIi8qIG5neC1tb21lbnQgKGMpIDIwMTUsIDIwMTYgVXJpIFNoYWtlZCAvIE1JVCBMaWNlbmNlICovXHJcblxyXG5pbXBvcnQge1BpcGUsIFBpcGVUcmFuc2Zvcm19IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50JztcclxuXHJcbkBQaXBlKHsgbmFtZTogJ2FtRnJvbVVuaXgnIH0pXHJcbmV4cG9ydCBjbGFzcyBGcm9tVW5peFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICB0cmFuc2Zvcm0odmFsdWU6IGFueSwgLi4uYXJnczogc3RyaW5nW10pOiBhbnkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdmFsdWUgPSArdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50LnVuaXgodmFsdWUpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuY29uc3QgbW9tZW50Q29uc3RydWN0b3IgPSBtb21lbnQ7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdhbVBhcnNlJyB9KVxyXG5leHBvcnQgY2xhc3MgUGFyc2VQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcbiAgdHJhbnNmb3JtKHZhbHVlOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKTogbW9tZW50Lk1vbWVudCB7XHJcbiAgICByZXR1cm4gbW9tZW50Q29uc3RydWN0b3IodmFsdWUsIGZvcm1hdCk7XHJcbiAgfVxyXG59XHJcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCIvKiBuZ3gtbW9tZW50IChjKSAyMDE1LCAyMDE2IFVyaSBTaGFrZWQgLyBNSVQgTGljZW5jZSAqL1xyXG5cclxuaW1wb3J0IHtQaXBlLCBQaXBlVHJhbnNmb3JtfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdhbUZyb21VdGMnIH0pXHJcbmV4cG9ydCBjbGFzcyBGcm9tVXRjUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG4gIHRyYW5zZm9ybSh2YWx1ZTogYW55LCAuLi5hcmdzOiBzdHJpbmdbXSk6IGFueSB7XHJcbiAgICByZXR1cm4gbW9tZW50LnV0Yyh2YWx1ZSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuY29uc3QgbW9tZW50Q29uc3RydWN0b3IgPSBtb21lbnQ7XHJcblxyXG5AUGlwZSh7XHJcbiAgbmFtZTogJ2FtSXNBZnRlcidcclxufSlcclxuZXhwb3J0IGNsYXNzIElzQWZ0ZXJQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcblxyXG4gIHRyYW5zZm9ybSh2YWx1ZTogRGF0ZSB8IG1vbWVudC5Nb21lbnQsXHJcbiAgICBvdGhlclZhbHVlOiBEYXRlIHwgbW9tZW50Lk1vbWVudCxcclxuICAgIHVuaXQ/OiBtb21lbnQudW5pdE9mVGltZS5TdGFydE9mKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gbW9tZW50Q29uc3RydWN0b3IodmFsdWUpLmlzQWZ0ZXIobW9tZW50Q29uc3RydWN0b3Iob3RoZXJWYWx1ZSksIHVuaXQpO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XHJcblxyXG5pbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5jb25zdCBtb21lbnRDb25zdHJ1Y3RvciA9IG1vbWVudDtcclxuXHJcbkBQaXBlKHtcclxuICBuYW1lOiAnYW1Jc0JlZm9yZSdcclxufSlcclxuZXhwb3J0IGNsYXNzIElzQmVmb3JlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG5cclxuICB0cmFuc2Zvcm0odmFsdWU6IERhdGUgfCBtb21lbnQuTW9tZW50LFxyXG4gICAgb3RoZXJWYWx1ZTogRGF0ZSB8IG1vbWVudC5Nb21lbnQsXHJcbiAgICB1bml0PzogbW9tZW50LnVuaXRPZlRpbWUuU3RhcnRPZik6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIG1vbWVudENvbnN0cnVjdG9yKHZhbHVlKS5pc0JlZm9yZShtb21lbnRDb25zdHJ1Y3RvcihvdGhlclZhbHVlKSwgdW5pdCk7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuY29uc3QgbW9tZW50Q29uc3RydWN0b3IgPSBtb21lbnQ7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdhbUxvY2FsJyB9KVxyXG5leHBvcnQgY2xhc3MgTG9jYWxUaW1lUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG4gICAgdHJhbnNmb3JtKHZhbHVlOiBEYXRlIHwgbW9tZW50Lk1vbWVudCB8IHN0cmluZyB8IG51bWJlcik6IG1vbWVudC5Nb21lbnQge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRDb25zdHJ1Y3Rvcih2YWx1ZSkubG9jYWwoKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuLy8gdW5kZXIgc3lzdGVtanMsIG1vbWVudCBpcyBhY3R1YWxseSBleHBvcnRlZCBhcyB0aGUgZGVmYXVsdCBleHBvcnQsIHNvIHdlIGFjY291bnQgZm9yIHRoYXRcclxuY29uc3QgbW9tZW50Q29uc3RydWN0b3IgPSBtb21lbnQ7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdhbUxvY2FsZScgfSlcclxuZXhwb3J0IGNsYXNzIExvY2FsZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgbG9jYWxlOiBzdHJpbmcpOiBtb21lbnQuTW9tZW50IHtcclxuICAgIHJldHVybiBtb21lbnRDb25zdHJ1Y3Rvcih2YWx1ZSkubG9jYWxlKGxvY2FsZSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdhbVBhcnNlWm9uZScgfSlcclxuZXhwb3J0IGNsYXNzIFBhcnNlWm9uZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZyk6IG1vbWVudC5Nb21lbnQge1xyXG4gICAgcmV0dXJuIG1vbWVudC5wYXJzZVpvbmUodmFsdWUpO1xyXG4gIH1cclxufVxyXG4iLCIvKiBuZ3gtbW9tZW50IChjKSAyMDE1LCAyMDE2IFVyaSBTaGFrZWQgLyBNSVQgTGljZW5jZSAqL1xyXG5cclxuaW1wb3J0IHtQaXBlLCBQaXBlVHJhbnNmb3JtfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XHJcblxyXG5jb25zdCBtb21lbnRDb25zdHJ1Y3RvciA9IG1vbWVudDtcclxuXHJcbkBQaXBlKHsgbmFtZTogJ2FtU3VidHJhY3QnIH0pXHJcbmV4cG9ydCBjbGFzcyBTdWJ0cmFjdFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICAgIHRyYW5zZm9ybSh2YWx1ZTogYW55LCBhbW91bnQ6IG1vbWVudC5EdXJhdGlvbklucHV0QXJnMSwgdW5pdD86IG1vbWVudC5EdXJhdGlvbklucHV0QXJnMik6IGFueSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICd1bmRlZmluZWQnIHx8ICh0eXBlb2YgYW1vdW50ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdW5pdCA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VidHJhY3RQaXBlOiBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9tZW50Q29uc3RydWN0b3IodmFsdWUpLnN1YnRyYWN0KGFtb3VudCwgdW5pdCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyogbmd4LW1vbWVudCAoYykgMjAxNSwgMjAxNiBVcmkgU2hha2VkIC8gTUlUIExpY2VuY2UgKi9cclxuXHJcbmltcG9ydCB7UGlwZSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIFBpcGVUcmFuc2Zvcm0sIE9uRGVzdHJveSwgTmdab25lfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XHJcblxyXG5jb25zdCBtb21lbnRDb25zdHJ1Y3RvciA9IG1vbWVudDtcclxuXHJcbkBQaXBlKHtuYW1lOiAnYW1UaW1lQWdvJywgcHVyZTogZmFsc2V9KVxyXG5leHBvcnQgY2xhc3MgVGltZUFnb1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtLCBPbkRlc3Ryb3kge1xyXG4gIHByaXZhdGUgY3VycmVudFRpbWVyOiBudW1iZXIgfCBudWxsO1xyXG5cclxuICBwcml2YXRlIGxhc3RUaW1lOiBOdW1iZXI7XHJcbiAgcHJpdmF0ZSBsYXN0VmFsdWU6IG1vbWVudC5Nb21lbnRJbnB1dDtcclxuICBwcml2YXRlIGxhc3RPbWl0U3VmZml4OiBib29sZWFuO1xyXG4gIHByaXZhdGUgbGFzdExvY2FsZT86IHN0cmluZztcclxuICBwcml2YXRlIGxhc3RUZXh0OiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2RSZWY6IENoYW5nZURldGVjdG9yUmVmLCBwcml2YXRlIG5nWm9uZTogTmdab25lKSB7XHJcbiAgfVxyXG5cclxuICB0cmFuc2Zvcm0odmFsdWU6IG1vbWVudC5Nb21lbnRJbnB1dCwgb21pdFN1ZmZpeD86IGJvb2xlYW4pOiBzdHJpbmcge1xyXG4gICAgaWYgKHRoaXMuaGFzQ2hhbmdlZCh2YWx1ZSwgb21pdFN1ZmZpeCkpIHtcclxuICAgICAgdGhpcy5sYXN0VGltZSA9IHRoaXMuZ2V0VGltZSh2YWx1ZSk7XHJcbiAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XHJcbiAgICAgIHRoaXMubGFzdE9taXRTdWZmaXggPSBvbWl0U3VmZml4O1xyXG4gICAgICB0aGlzLmxhc3RMb2NhbGUgPSB0aGlzLmdldExvY2FsZSh2YWx1ZSk7XHJcbiAgICAgIHRoaXMucmVtb3ZlVGltZXIoKTtcclxuICAgICAgdGhpcy5jcmVhdGVUaW1lcigpO1xyXG4gICAgICB0aGlzLmxhc3RUZXh0ID0gbW9tZW50Q29uc3RydWN0b3IodmFsdWUpLmZyb20obW9tZW50Q29uc3RydWN0b3IoKSwgb21pdFN1ZmZpeCk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jcmVhdGVUaW1lcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmxhc3RUZXh0O1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICB0aGlzLnJlbW92ZVRpbWVyKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZVRpbWVyKCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudFRpbWVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtb21lbnRJbnN0YW5jZSA9IG1vbWVudENvbnN0cnVjdG9yKHRoaXMubGFzdFZhbHVlKTtcclxuICAgIGNvbnN0IHRpbWVUb1VwZGF0ZSA9IHRoaXMuZ2V0U2Vjb25kc1VudGlsVXBkYXRlKG1vbWVudEluc3RhbmNlKSAqIDEwMDA7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50VGltZXIgPSB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmxhc3RUZXh0ID0gbW9tZW50Q29uc3RydWN0b3IodGhpcy5sYXN0VmFsdWUpLmZyb20obW9tZW50Q29uc3RydWN0b3IoKSwgdGhpcy5sYXN0T21pdFN1ZmZpeCk7XHJcblxyXG4gICAgICAgICAgdGhpcy5jdXJyZW50VGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMuY2RSZWYubWFya0ZvckNoZWNrKCkpO1xyXG4gICAgICAgIH0sIHRpbWVUb1VwZGF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW1vdmVUaW1lcigpIHtcclxuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lcikge1xyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudFRpbWVyKTtcclxuICAgICAgdGhpcy5jdXJyZW50VGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRTZWNvbmRzVW50aWxVcGRhdGUobW9tZW50SW5zdGFuY2U6IG1vbWVudC5Nb21lbnQpIHtcclxuICAgIGNvbnN0IGhvd09sZCA9IE1hdGguYWJzKG1vbWVudENvbnN0cnVjdG9yKCkuZGlmZihtb21lbnRJbnN0YW5jZSwgJ21pbnV0ZScpKTtcclxuICAgIGlmIChob3dPbGQgPCAxKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfSBlbHNlIGlmIChob3dPbGQgPCA2MCkge1xyXG4gICAgICByZXR1cm4gMzA7XHJcbiAgICB9IGVsc2UgaWYgKGhvd09sZCA8IDE4MCkge1xyXG4gICAgICByZXR1cm4gMzAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIDM2MDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhhc0NoYW5nZWQodmFsdWU6IG1vbWVudC5Nb21lbnRJbnB1dCwgb21pdFN1ZmZpeD86IGJvb2xlYW4pOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRpbWUodmFsdWUpICE9PSB0aGlzLmxhc3RUaW1lXHJcbiAgICAgIHx8IHRoaXMuZ2V0TG9jYWxlKHZhbHVlKSAhPT0gdGhpcy5sYXN0TG9jYWxlXHJcbiAgICAgIHx8IG9taXRTdWZmaXggIT09IHRoaXMubGFzdE9taXRTdWZmaXg7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldFRpbWUodmFsdWU6IG1vbWVudC5Nb21lbnRJbnB1dCk6IG51bWJlciB7XHJcbiAgICBpZiAobW9tZW50LmlzRGF0ZSh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKTtcclxuICAgIH0gZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUudmFsdWVPZigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG1vbWVudENvbnN0cnVjdG9yKHZhbHVlKS52YWx1ZU9mKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldExvY2FsZSh2YWx1ZTogbW9tZW50Lk1vbWVudElucHV0KTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gbW9tZW50LmlzTW9tZW50KHZhbHVlKSA/IHZhbHVlLmxvY2FsZSgpIDogbW9tZW50LmxvY2FsZSgpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuY29uc3QgbW9tZW50Q29uc3RydWN0b3IgPSBtb21lbnQ7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdhbVV0YycgfSlcclxuZXhwb3J0IGNsYXNzIFV0Y1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICB0cmFuc2Zvcm0odmFsdWU6IERhdGUgfCBtb21lbnQuTW9tZW50IHwgc3RyaW5nIHwgbnVtYmVyKTogbW9tZW50Lk1vbWVudCB7XHJcbiAgICByZXR1cm4gbW9tZW50Q29uc3RydWN0b3IodmFsdWUpLnV0YygpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBOR1hfTU9NRU5UX09QVElPTlMsIE5neE1vbWVudE9wdGlvbnMgfSBmcm9tICcuL21vbWVudC1vcHRpb25zJztcclxuXHJcbmltcG9ydCB7IEFkZFBpcGUgfSBmcm9tICcuL2FkZC5waXBlJztcclxuaW1wb3J0IHsgQ2FsZW5kYXJQaXBlIH0gZnJvbSAnLi9jYWxlbmRhci5waXBlJztcclxuaW1wb3J0IHsgRGF0ZUZvcm1hdFBpcGUgfSBmcm9tICcuL2RhdGUtZm9ybWF0LnBpcGUnO1xyXG5pbXBvcnQgeyBEaWZmZXJlbmNlUGlwZSB9IGZyb20gJy4vZGlmZmVyZW5jZS5waXBlJztcclxuaW1wb3J0IHsgRHVyYXRpb25QaXBlIH0gZnJvbSAnLi9kdXJhdGlvbi5waXBlJztcclxuaW1wb3J0IHsgRnJvbVVuaXhQaXBlIH0gZnJvbSAnLi9mcm9tLXVuaXgucGlwZSc7XHJcbmltcG9ydCB7IEZyb21VdGNQaXBlIH0gZnJvbSAnLi9mcm9tLXV0Yy5waXBlJztcclxuaW1wb3J0IHsgSXNBZnRlclBpcGUgfSBmcm9tICcuL2lzLWFmdGVyLnBpcGUnO1xyXG5pbXBvcnQgeyBJc0JlZm9yZVBpcGUgfSBmcm9tICcuL2lzLWJlZm9yZS5waXBlJztcclxuaW1wb3J0IHsgTG9jYWxUaW1lUGlwZSB9IGZyb20gJy4vbG9jYWwucGlwZSc7XHJcbmltcG9ydCB7IExvY2FsZVBpcGUgfSBmcm9tICcuL2xvY2FsZS5waXBlJztcclxuaW1wb3J0IHsgUGFyc2VQaXBlIH0gZnJvbSAnLi9wYXJzZS5waXBlJztcclxuaW1wb3J0IHsgUGFyc2Vab25lUGlwZSB9IGZyb20gJy4vcGFyc2Utem9uZS5waXBlJztcclxuaW1wb3J0IHsgU3VidHJhY3RQaXBlIH0gZnJvbSAnLi9zdWJ0cmFjdC5waXBlJztcclxuaW1wb3J0IHsgVGltZUFnb1BpcGUgfSBmcm9tICcuL3RpbWUtYWdvLnBpcGUnO1xyXG5pbXBvcnQgeyBVdGNQaXBlIH0gZnJvbSAnLi91dGMucGlwZSc7XHJcblxyXG5jb25zdCBBTkdVTEFSX01PTUVOVF9QSVBFUyA9IFtcclxuICBBZGRQaXBlLFxyXG4gIENhbGVuZGFyUGlwZSxcclxuICBEYXRlRm9ybWF0UGlwZSxcclxuICBEaWZmZXJlbmNlUGlwZSxcclxuICBEdXJhdGlvblBpcGUsXHJcbiAgRnJvbVVuaXhQaXBlLFxyXG4gIFBhcnNlUGlwZSxcclxuICBTdWJ0cmFjdFBpcGUsXHJcbiAgVGltZUFnb1BpcGUsXHJcbiAgVXRjUGlwZSxcclxuICBGcm9tVXRjUGlwZSxcclxuICBMb2NhbFRpbWVQaXBlLFxyXG4gIExvY2FsZVBpcGUsXHJcbiAgUGFyc2Vab25lUGlwZSxcclxuICBJc0JlZm9yZVBpcGUsXHJcbiAgSXNBZnRlclBpcGVcclxuXTtcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgZGVjbGFyYXRpb25zOiBBTkdVTEFSX01PTUVOVF9QSVBFUyxcclxuICBleHBvcnRzOiBBTkdVTEFSX01PTUVOVF9QSVBFU1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTW9tZW50TW9kdWxlIHtcclxuICBzdGF0aWMgZm9yUm9vdChvcHRpb25zPzogTmd4TW9tZW50T3B0aW9ucyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE1vbWVudE1vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogTkdYX01PTUVOVF9PUFRJT05TLCB1c2VWYWx1ZToge1xyXG4gICAgICAgICAgICAuLi5vcHRpb25zXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiUGlwZSIsIm1vbWVudENvbnN0cnVjdG9yIiwibW9tZW50LmlzTW9tZW50IiwiRXZlbnRFbWl0dGVyIiwiQ2hhbmdlRGV0ZWN0b3JSZWYiLCJOZ1pvbmUiLCJJbmplY3Rpb25Ub2tlbiIsIm1vbWVudC5kdXJhdGlvbiIsIm1vbWVudC5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJPcHRpb25hbCIsIkluamVjdCIsIm1vbWVudC51bml4IiwibW9tZW50LnV0YyIsIm1vbWVudC5wYXJzZVpvbmUiLCJtb21lbnQuaXNEYXRlIiwibW9tZW50LmxvY2FsZSIsIk5nTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQUtNLGlCQUFpQixHQUFHLE1BQU07QUFFaEM7UUFBQTtTQVFDOzs7Ozs7O1FBTkcsMkJBQVM7Ozs7OztZQUFULFVBQVUsS0FBVSxFQUFFLE1BQWdDLEVBQUUsSUFBK0I7Z0JBQ25GLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxLQUFLLE9BQU8sTUFBTSxLQUFLLFFBQVEsSUFBSSxPQUFPLElBQUksS0FBSyxXQUFXLENBQUMsRUFBRTtvQkFDOUYsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO2lCQUMxRDtnQkFDRCxPQUFPLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDckQ7O29CQVBKQSxTQUFJLFNBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFOztRQVF2QixjQUFDO0tBUkQ7Ozs7Ozs7UUNETUMsbUJBQWlCLEdBQUcsTUFBTTtBQUVoQztRQWFFLHNCQUFvQixLQUF3QixFQUFVLE1BQWM7WUFBcEUsaUJBV0M7WUFYbUIsVUFBSyxHQUFMLEtBQUssQ0FBbUI7WUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFROztZQUVsRSxZQUFZLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRS9CLFlBQVks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